\documentclass{jsbook}

\usepackage[dvipdfmx]{graphicx}
\usepackage{ascmac}
\usepackage{url}
\usepackage[dvipdfmx]{color}
\usepackage[dvipdfmx]{colortbl}
\usepackage{here}

\def\mod#1{\textcolor{red}{#1}}

\title{Synthesijer 2.0 ユーザー ガイド}
\date{\today \\ 第0.1版}
%\author{三好健文\\わさらぼ合同会社}

\setlength{\textwidth}{\fullwidth}
\setlength{\evensidemargin}{\oddsidemargin}

\begin{document}

\arrayrulecolor{black}
%\setlength\arrayrulewidth{.4pt}
%\setlength{\extrarowheight}{.4pt}
%\newcolumntype{A}{>{\columncolor[rgb]{0.8,0.8,0.8}}p{2cm}}

\maketitle

\begin{abstract}
SynthesijerはJavaベースの高位合成処理系です．ソフトウェアとして実行可能なJavaで書かれたプログラムから，同様の動作を行うVHDLあるいはVerilog HDLコードを生成します．生成したVHDLあるいはVerilog HDLのコードはFPGAベンダの提供する開発環境を使ってFPGA上のハードウェア情報に変換できます．
\end{abstract}

\begin{table}[htbp]
\begin{center}
 \caption{改訂履歴}
 \label{tbl:history}
 \begin{tabular}{|p{6zw}|p{2zw}|p{2zw}|p{30zw}|}\hline
\rowcolor[rgb]{0.87, 0.89, 0.91} 日付 & 版 & 項番 & 修正内容 \\\hline
 2014/12/20 & 0.1 & - & 初版 \\\hline
 \end{tabular} 
\end{center}
\end{table}

\tableofcontents
\listoftables
\listoffigures

\chapter{Javaベースの高位合成処理系 Synthesijer とは}

Field Programmable Gate Array(FPGA)は，プログラム可能なハードウェアデバイスで，
ユーザが自由にハードウェアロジックをその上に構築できます．
実行したい処理中の並列性を活用することで，プロセッサによるソフトウェア処理に比べ，
低消費電力で高い処理能力を得ることができます．

FPGAの性能を効率良く活用するためには，一般に，VHDLやVerilogを用いたRegister Transfer Level(RTL)の設計が行われています．
しかし，アルゴリズムとして複雑な処理のRTL記述は繁雑で手間がかかり，時にはバグの温床となります．
そのため，RTLより高い抽象度でのハードウェア設計を可能にする高位合成言語が求められています．
高位合成言語には，設計の繁雑さを解消しながら，FPGAのパフォーマンスを引き出すことが要求されます．

%% たとえば，高水準言語にハードウェア設計のために必要な拡張を加えることで，
%% RTLより高い抽象度のハードウェア設計を可能にする高位合成言語があります．
%% これらの高位設計言語では，元となる高水準言語に特別な型やクラスライブラリ，文法などを追加することで
%% ハードウェアの要素やハードウェア上での処理の振舞いを表現できるように拡張が加えられています．
%% また，FPGAで効率良く処理を実行させるために処理内のデータ並列性とパイプライン並列性を抽出するための，
%% アノテーションやコンパイラへの指示子が導入されています．
%% これらの高位合成言語を用いることで，
%% 高水準言語のもつ有用な機能を利用した簡単なHDL設計で，FPGAを効率良く活用できます．
%% 
%% しかしながら，それらのツールでは，
%% 高水準言語の機能を用いて記述された部分とハードウェア化の対象となる部分のコードを混在させることができません．
%% また，ハードウェアとして最適化するように指示した箇所のコードはソフトウェアとして実行することができません．
%% そのため，処理の検証には，それぞれの言語に向けて開発されたシミュレータかRTLでの検証が必要となります．
%% すなわち，単にソフトウェアをプログラムとして実行した場合に比べて検証時間は長く，
%% また使える手段が限られます．
%% 
%% プログラム言語を拡張することなく，既存の言語で記述されたプログラムからハードウェアへの合成を可能にする手法もあります．
%% これらは，プログラミング言語Cで記述されたプログラムからハードウェアの合成を可能にする．
%% 入力されるプログラムは，元来Cで記述されているため，
%% 一般的なCコンパイラでコンパイルすればコンピュータの上でソフトウェアとして動作させることができる．
%% これらは，新たなプログラミング習得の手間なしでプログラムをハードウェアとして実装でき，
%% また，ソフトウェアとしてアルゴリズムレベルでのデバッグが可能になるため，開発の繁雑さを解消している．
%% 
%% しかしながら，Cで記述されたプログラムを対象とするため，ポインタをどのように合成処理系で取り扱うかという課題が生じる．
%% また，FPGAでは，性能向上の実現のために処理を並列に実行することが一般的なアプローチであるが，
%% Cの言語仕様には並列処理をどのように扱うかという規定がない．
%% % Cではスレッドの取り扱いができない，という点も課題である．
%% そのため，スレッドレベルやタスクレベルの並列性をプログラマ自身が簡単に記述できるように，
%% それぞれの処理系で独自にサポートしなければならない．
%% そのため，各処理系に合わせて，プログラマが，
%% ソフトウェアの記述方法と，そのハードウェアでの実現方式を意識してプログラミングしなければならず，
%% プログラミングのコストが大きいという課題は以前として残る．% 増大し，開発の繁雑さの解消には，依然問題が残る．
%% 
%% 特定の高水準言語をベースとするのではなく，新しく設計された高位合成言語もある．
%% Bluespec System Verilog\cite{bluespec}(BSV)は，
%% ハードウェア設計に関数型言語の特徴を取り入れ，高階関数による強力な抽象的な設計手法と，
%% 強力な型システムによる頑健な設計を可能にする新しいハードウェア記述言語である．
%% BSVでは，これらの高水準言語としての機能をすべてハードウェア化することができる．
%% しかし，関数型言語とHDLという二種類のパラダイムを融合したこの言語は，修得コストが大きい．
%% また高速なシミュレータを持つものの，ソフトウェアとして処理を実行する場合に比べると，
%% デバッグに使える手法の幅が少なく，アルゴリズムレベルのデバッグは簡単ではない．

Synthesijerは，Javaプログラムからそのままハードウェアを合成する高位合成処理系です．
Javaプログラムをソフトウェアとしてコンピュータ上で実行してアルゴリズムレベルのデバッグを行い，
その十分にデバッグしたプログラムをハードウェア化することで，RTL設計以降でのアルゴリズムレベルのデバッグが不要になります．
%JHDLやMaxCompilerのように特別なクラスを導入することでハードウェア設計を行なう訳ではない．
%% 従って，
新たなプログラミング習得の手間は必要なく，
ソフトウェアとしてアルゴリズムレベルでのデバッグが可能になることで，開発の繁雑さが解消されます．

多くの高位合成処理系はC言語をベースとしている中，SynthesijerはJavaを選択しました．
Javaを選択した理由は広く普及しているからということに加えて，
並列処理を記述可能なThreadを言語仕様として含むため，ソフトウェアアプログラマにとって
自然な形でハードウェアでも並列性を活用できます．
また，Cでは明示的に処理系がポインタを扱う必要があり，どのように合成処理系で取り扱うかという課題がありますが，
Javaの場合ポインタは処理系内部に隠蔽されているため，ソフトウェアで意識する必要がないというメリットがあります．

しかし，ハードウェア設計に必要となる，クロックの取り扱い手法や，データの保持されるタイミング，
細粒度での処理同期や，パイプライン/データ並列性を活用するプログラムはJavaでは記述できません．
そのため，JavaだけでFPGAの性能を十分に活用することは簡単ではありません．

とはいえ，Javaで記述された処理を実行するためのプロセッサ機構を構成するのではなく，
直接的にハードウェア化することで，フェッチやデコードなどのソフトウェア処理のための機構が省略され，演算密度は高くなります．
そのため，FPGAを用いることでの処理の高速化や消費電力の削減などの効果が期待できます．
また，HDLで独自に記述したFPGAのために最適化されたモジュールをJavaから簡単に呼び出せる仕組みを提供することで，
ボトルネックとなる部分的な処理をユーザがHDLで記述することで性能向上を図ることができます．

実際に，FPGAが使用されたアプリケーションの実装に目を向けてみると，
処理の本体でないI/O処理や複雑な逐次処理部分に対しては，
補助的なプロセッサの利用や愚直に実装されたステートマシンで処理されているケースが多数みられます．
このようなケースでは，クロックを意識して高度に最適化したハードウェアと，
高位合成言語から生成されたハードウェアとの間に有意な性能差がみられないと考えられます．
補助的なプロセッサを用いると，
プロセッサ用のコードやツールセットの整備と保守が必要になり，開発コストが増加してしまいます．
すなわち，多少の性能低下によるデメリットがあっても，開発コストを削減できるというメリットで上回ると考えられます．

\section{Synthesijerを用いた開発フロー概要}
\begin{enumerate}
 \item コンパイル済みのクラスファイルをアーカイブしたSynthesijerのJARファイルをダウンロードします\footnote{http://synthesijer.sourceforge.net からダウンロードできます}．
 \item 馴染みの環境でHW化するJavaプログラムを書きます．開発環境で(1)でダウンロードしたJARファイルへのクラスパスを追加しておくとアノテーションや組み込みライブラリを使用する場合に補完がきいて便利です．
 \item JavaプログラムをSynthesijerでコンパイルし，VHDLまたはVerilog HDLを作成します．
 \item できあがったHDLを，いつもの合成・配置配線ツールでFPGA用のbitファイルに変更します．必要に応じてピン配置などの制約が必要になるでしょう．
\end{enumerate}

\section{Synthesijerの使用方法}
Synthesijerはコマンドラインプログラムです．
ホームページからダウンロードしたJARファイルの名前を\verb|synthesijer-YYYYMMDD.jar|とします．

\subsection{Windowsの場合の実行方法}
Windowsの場合DOSプロンプトを使ってSynthesijerを実行します．ダウンロードしたJARと合成対象のソースコードがコンパイルされるクラスパスを指定して実行します．合成対象のJavaソースコードはすべて引数で指定する必要があります．
\begin{figure}[H]
 \begin{quote}
  \begin{screen}
\begin{verbatim}
java -cp synthesijer-YYYYMMDD.jar;. synthesijer.Main コンパイル対象のファイル
\end{verbatim}
  \end{screen}
 \end{quote} 
 \caption{Windowsでの実行}
 \label{fig:windows_execution}
\end{figure}
この例では，カレントディレクトリのみをクラスパスとして追加しています．
合成が成功すると，Javaのソースコードに対応したHDLコードおよびコード生成時の中間データがカレントディレクトリに出力されます．

Cygwinを使って実行することもできます．ただし，クラスパス区切り文字の\verb|;|(セミコロン)がShellのコマンド終了に相当してしまいますので\verb|\"|(ダブルクオーテーション)で囲む必要があります．
\begin{figure}[H]
 \begin{quote}
  \begin{screen}
\begin{verbatim}
java -cp "synthesijer-YYYYMMDD.jar;." synthesijer.Main [オプション] コンパイル対象
\end{verbatim}
  \end{screen}
 \end{quote} 
 \caption{Windowsでの実行}
 \label{fig:windows_execution}
\end{figure}
またCygwin上での絶対パスはJavaプログラムでは解決されないので注意が必要です．相対パスで指定するかWindowsのファイルシステム上のパスを指定する必要があります．

\subsection{Unix系OSの場合の実行方法}
PC-Unix系，Linux，MacOSXなどのUnix系OSの場合はターミナルを使ってSynthesijerを実行します．
ダウンロードしたJARと合成対象のソースコードがコンパイルされるクラスパスを指定して実行します．合成対象のJavaソースコードはすべて引数で指定する必要があります．
\begin{figure}[H]
 \begin{quote}
  \begin{screen}
\begin{verbatim}
java -cp synthesijer-YYYYMMDD.jar:. synthesijer.Main [オプション] コンパイル対象
\end{verbatim}
  \end{screen}
 \end{quote} 
 \caption{Unix系OSでの実行}
 \label{fig:unix_execution}
\end{figure}
この例では，カレントディレクトリのみをクラスパスとして追加しています．
合成が成功すると，Javaのソースコードに対応したHDLコードおよびコード生成時の中間データがカレントディレクトリに出力されます．

\subsection{オプション}
表\ref{tbl:options}はSynthesijerで指定可能なオプションです．
\begin{table}[H]
 \caption{オプション 一覧}
 \label{tbl:options}
\begin{center}
 \begin{tabular}{l|l} \hline
   オプション & 内容 \\\hline\hline
   -h        & ヘルプを表示します \\\hline
   --help    & ヘルプを表示します \\\hline
   --vhdl    & VHDLファイルを生成します \\\hline
   --verilog & Verilog HDLファイルを生成します \\\hline
   --no-optimize & 最適化機構をオフにする \\\hline
 \end{tabular}
\end{center}
\end{table}
\verb|--vhdl|も\verb|--verilog|のどちらのオプションも指定しなかった場合には，VHDLファイルを生成します．両方同時に指定することもできます．両方指定した場合には，VHDLファイルとVerilog HDLの両方を生成します．

\subsection{生成されるファイル}
SynthesijerではHDLファイルの他に生成時の中間情報のファイルを同時に生成します．たとえば，Foo.javaに対して生成されるファイルは表\ref{tbl:generated_files}の通りです．
\begin{table}[H]
 \caption{生成されるファイル 一覧}
 \label{tbl:generated_files}
\begin{center}
 \begin{tabular}{l|l} \hline
   ファイル  & 内容 \\\hline\hline
   Foo.class & classファイル．JVMで実行できる．\\\hline
   Foo.vhd   & 生成されたVHDLファイル \\\hline
   Foo.v     & 生成されたVerilog HDLファイル \\\hline
   Foo\_scheduler\_*.txt & 中間状態のスケジューラのテキスト出力 \\\hline
   Foo\_scheduler\_*.dot & 中間状態のスケジューラの状態遷移グラフ(GraphvizのDOT形式) \\\hline
 \end{tabular}
\end{center}
\end{table}

\section{クイックスタートガイド}
例題を通じてSynthesijerを使った開発フローを紹介します．
ホームページからダウンロードしたJARファイルの名前を\verb|synthesijer-YYYYMMDD.jar|としています．実行する時には，ダウンロードした実際のファイル名と読み代えてください．

図\ref{fig:quick_start_sample}にサンプルコードを示します．
\begin{figure}[H]
\begin{quote}
  \begin{screen}
 \begin{verbatim}
public class Test{
    public boolean flag;
    private int count;

    public void run(){
        while(true){
            count++;
            if(count > 5000000){
                count = 0;
                flag = !flag;
            }
         }
    }
} \end{verbatim}
 \end{screen}
\end{quote} 
 \caption{サンプルコード Test.java}
 \label{fig:quick_start_sample}
\end{figure}
このJavaプログラムのrunメソッドが呼び出されると，インスタンス変数の\verb|count|をインクリメントし続けます．ただし，\verb|count|が\verb|5000000|を越えた時点で\verb|0|にリセットすると同時にインスタンス変数の\verb|flag|の真偽を反転します．Javaでは\verb|public|クラスはクラス名と同じ名前のファイルに保存しなければいけません．サンプルコードは\verb|Test.java|という名前で保存しましょう．

プログラムをSynthesijerを使ってコンパイルしましょう．ダウンロードしたJARファイルへのクラスパスを指定して，図\ref{fig:quick_start_command}のように\verb|synthesijer.Main|を実行します．引数にコンパイル対象のファイル，この例では\verb|Test.java|を指定します．
\begin{figure}[H]
\begin{quote}
  \begin{screen}
\begin{verbatim}
java -cp synthesijer-YYYYMMDD.jar synthesijer.Main Test.java
\end{verbatim}
 \end{screen}
\end{quote} 
 \caption{Synthesijerを使って合成する}
 \label{fig:quick_start_command}
\end{figure}

SynthesijerはデフォルトではVHDLファイルを生成します．Verilog HDLコードを生成したい場合には，図\ref{fig:quick_start_command_verilog}のように\verb|--verilog|オプションを付けて実行します．
\begin{figure}[H]
\begin{quote}
  \begin{screen}
\begin{verbatim}
java -cp synthesijer-YYYYMMDD.jar synthesijer.Main --verilog Test.java
\end{verbatim}
 \end{screen}
\end{quote} 
 \caption{Synthesijerを使ってVerilog HDLファイルを生成する}
 \label{fig:quick_start_command_verilog}
\end{figure}
ちなみに，\verb|--verilog|と\verb|--vhdl|オプションを両方付けて実行するとVHDLとVerilog HDLのコードを同時に生成します．

生成されたVHDLコードのエンティティを図\ref{fig:generated_hdl_entity}に示します．
\begin{figure}[H]
\begin{quote}
  \begin{screen}
\begin{verbatim}
entity Test is
  port (
    clk      : in  std_logic;
    reset    : in  std_logic;
    flag_out : out std_logic;
    flag_in  : in  std_logic;
    flag_we  : in  std_logic;
    run_req  : in  std_logic;
    run_busy : out std_logic
  );
end Test;
\end{verbatim}
 \end{screen}
\end{quote} 
 \caption{生成されたVHDLコードのエンティティ}
 \label{fig:generated_hdl_entity}
\end{figure}
\verb|clk|，\verb|reset|はクロックとリセット信号です．Synthesijerで生成されるモジュールは\verb|clk|に同期する回路になります．\verb|reset|は正論理のリセット信号です．\verb|flag_{in,out,we}|は，元のソースコード(図\ref{fig:quick_start_sample})の\verb|public|変数である\verb|flag|に対応する読み書き用のポートです．最後の\verb|run_{req,busy}|が\verb|run|メソッド呼び出し用の制御ポートです．
なお，\verb|private|変数である\verb|count|は外からアクセスされるべき変数ではないのでポートとして生成されません．


\chapter{HDLモジュールの利用方法}

\chapter{生成モデル}

Javaに対応したハードウェアの生成モデルについて述べます．

\section{サポートされない言語機能}
SynthesijerはすべてのJavaプログラムを受理できるわけではありません．
基本的に動的なインスタンス生成機能は使用できません．
また，catch節の帯域脱出，再帰呼び出しは利用できません．
Thread以外の継承，インターフェースとその実装(implement)は未サポートです．

\section{クラス}

\section{関数}

\section{演算子}

\section{制御構造}

\section{配列}

\section{データ型}

\section{アノテーション}

\chapter{Synthesijer リファレンスガイド}

\appendix
\chapter{その他のリソース}

\end{document}
